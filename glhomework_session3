'use strict'

////////////////////////// 
// 1st task

function compareObjects(obj1, obj2, prop) {
	if (obj1 instanceof Object && 
		obj2 instanceof Object && 
		obj1.hasOwnProperty(prop) && 
		obj2.hasOwnProperty(prop) ) {

	obj1[prop] > obj2[prop] ? console.log(obj1.name) :
		obj1[prop] < obj2[prop] ? console.log(obj2.name) :
			obj1[prop] === obj2[prop] ? console.log(obj1.name+' equals to '+obj2.name) : console.log('type of \''+prop+'\' is not a Number');

	} else {
		console.log("ads");
	};
};

function MyObject (name, number) {
	this.name = name,
	this.number = number 
};


var o1 = {
	name : 'Object1',
	number : getRandomNumber()
};
var o2 = new MyObject('Object2', getRandomNumber());

compareObjects(o1,o2,'number');


//////////////////////////
// 2nd task

function getRandomNumber() {
	return Math.floor(Math.random()*100);
}

var songCollection = [
	{
		name : 'Song1',
		played : getRandomNumber()
	},
	{
		name : 'Song2',
		played : getRandomNumber()
	},
	{
		name : 'Song3',
		played : getRandomNumber()
	},
	{
		name : 'Song4',
		played : getRandomNumber()
	},
	{
		name : 'Song5',
		played : getRandomNumber()
	}
];

function favoriteSong(collection) {
	var resultObj = {
		id : 0,
		played : 0
	};
	for (var id=0; id<collection.length; id++){
		if(collection[id].played > resultObj.played) {
			resultObj.id = id;
			resultObj.played = collection[id].played;
		};
	};
	// return { 
	// 	name: collection[resultObj.id].name,
	// 	id: resultObj.id,
	// 	played: collection[resultObj.id].played
	// }
	console.log(collection[resultObj.id].name+', with id: '+ resultObj.id +' in songCollection. It was played '+collection[resultObj.id].played+' times.');
};

favoriteSong(songCollection);

///////////////////////////////
// 3d task

function Calculator() {
	var sum = [],
		counter = 0;
	this.add = num => {
		counter === 0 ? sum[counter]=num : sum[counter]=sum[counter-1]+num;
		counter += 1;
	};
	this.getCurrentSum = id => {
		if (typeof id === 'number' && id !== 0){
			return sum[id-1];
		} else if (id === undefined) {
			return sum[sum.length-1];
		} else {
			console.log('INPUT NUMBER')
		};
	};
};

var first = new Calculator();
var	second = new Calculator();
first.add(3);
first.add(8);
first.add(11);
second.add(5);
second.add(12);
second.add(17);

console.log(first.getCurrentSum() + second.getCurrentSum());  // 56
console.log(first.getCurrentSum(2) + second.getCurrentSum(2));  // 28
console.log(first.getCurrentSum(3) === first.getCurrentSum());  // true


/////////////////////
// deep copy

/*
Функция выполняет глубокое копирование объектов.
Функция максимально приблежена к функции Object.assign(target, ...sources), она может принимать в аргумент
source сколько угодно объектов, а так же выполняет копирывание массивов.
*/
function deepCopy(target, ...source) {
	// id - порядковый номер введеного source, resultSourse - резулльтирующий массив, в который глубоко копируются объекты.
	var id = 0,
		resultSource = [];

	source.forEach( source => {
		resultSource[id] = {};
		for (var key in source){
			if (source[key] instanceof Object){

				// Если свойством является объект - рекурсивно вызываем нашу функцию и результат пишем в свойство.
				resultSource[id][key] = deepCopy({},source[key]);
			} else {

				// Всё остальное нас не интересует.
				resultSource[id][key] = source[key];
			};
		};
		id++;
	});

	// Возвращаем объект с глубоко прокопированным resultSource
	return Object.assign(target, ...resultSource);
};

var test = {
	w:{
		x:{
			z: {
				y:1
			}
		}
	},
	x:[
		{
			a:[]
		}
	],
	a:1,
	b:2
};


var test1 = deepCopy({},test);   
console.log(test.w.x.z === test1.w.x.z);  // false 
console.log(test.x[0] === test1.x[0]) // false P.S. посмотрел, что дефолтный assign test.x === test1.x тоже вернет falseW:)
